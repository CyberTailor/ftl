module stdVectorModule

! Vectors are sequence containers representing arrays that can change in size.
!
! Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be
! accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size
! can change dynamically, with their storage being handled automatically by the container.
!
! Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to
! grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a
! relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the
! container.
!
! Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have
! an actual capacity greater than the storage strictly needed to contain its elements (i.e., its size). Libraries can implement
! different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only
! happen at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be
! provided with amortized constant time complexity (see push_back).
!
! Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in
! an efficient way.
!
! Compared to the other dynamic sequence containers (deques, lists and forward_lists), vectors are very efficient accessing its
! elements (just like arrays) and relatively efficient adding or removing elements from its end. For operations that involve
! inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent
! iterators and references than lists and forward_lists.

   implicit none

   type stdVector

      integer :: size = 0
      real, allocatable :: data(:)

   contains

      procedure :: NewDefault
      procedure :: NewFill
      procedure :: NewFromArray
      generic   :: New => NewDefault, NewFill, NewFromArray

      procedure :: Delete

      procedure :: AssignArray
                 ! assignment of another stdVector is auto generated by the compiler
      generic   :: assignment(=) => AssignArray

      ! ==> Capacity:

      procedure :: Resize
      procedure :: Capacity
      procedure :: Empty

      ! ==> Element Access:

      !          TODO

      ! ==> Modifiers:

      procedure :: PushBack
      procedure :: PopBack

      procedure :: InsertSingle
      procedure :: InsertFill
      procedure :: InsertArray
      generic   :: Insert => InsertSingle, InsertFill, InsertArray

      ! ==> Private methods:
      procedure, private :: ChangeCapacity
      procedure, private :: IncreaseCapacity

   end type


contains


   subroutine NewDefault(self)
      class(stdVector), intent(out) :: self

      ! Constructs an empty container, with no elements.

      allocate(self%data(0))

   end subroutine



   subroutine NewFill(self, n, val)
      class(stdVector), intent(out)          :: self
      integer         , intent(in)           :: n
      real            , intent(in), optional :: val

      ! Constructs a container with n elements. Each element is a copy of val (if present).

      allocate(self%data(n))
      if (present(val)) self%data = val
      self%size = n

   end subroutine



   subroutine NewFromArray(self, array)
      class(stdVector), intent(out) :: self
      real,             intent(in)  :: array(:)

      ! Constructs a container with a copy of each of the elements in arr, in the same order.

      allocate(self%data(size(array)))
      self%data = array
      self%size = size(array)

   end subroutine



   subroutine Delete(self)
      class(stdVector), intent(out) :: self

      ! Nothing to do here: intent(out) will deallocate self%data and set self%size = 0

   end subroutine



   subroutine AssignArray(self, array)
      class(stdVector), intent(out) :: self
      real,             intent(in)  :: array(:)

      ! Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.

      call self%NewFromArray(array)

   end subroutine



! =============> Capacity:



   subroutine resize(self, n, val)
      class(stdVector), intent(inout)        :: self
      integer         , intent(in)           :: n
      real            , intent(in), optional :: val

      ! Resizes the container so that it contains n elements.
      !
      ! If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond
      ! (and destroying them).
      !
      ! If n is greater than the current container size, the content is expanded by inserting at the end as many elements as
      ! needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are
      ! value-initialized.
      !
      ! If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes
      ! place.
      !
      ! Notice that this function changes the actual content of the container by inserting or erasing elements from it.

      if (n > self%Capacity()) call self%ChangeCapacity(n)
      if (present(val) .and. n > self%size) self%data(self%size+1:n) = val
      ! TODO: call destructor on removed elements when shrinking
      self%size = n

   end subroutine



   pure integer function Capacity(self)
      class(stdVector), intent(in) :: self

      ! Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.
      !
      ! This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to
      ! accommodate for growth without the need to reallocate on each insertion.
      !
      ! Notice that this capacity does not suppose a limit on the size of the vector. When this capacity is exhausted and more is
      ! needed, it is automatically expanded by the container (reallocating it storage space).
      !
      ! The capacity of a vector can be explicitly altered by calling member stdVector%reserve.

      if (allocated(self%data)) then
         Capacity = size(self%data)
      else
         Capacity = 0
      endif

   end function



   pure logical function Empty(self)
      class(stdVector), intent(in) :: self

      ! Returns whether the vector is empty (i.e. whether its size is 0).
      !
      ! This function does not modify the container in any way. To clear the content of a vector, see stdVector%clear.

      Empty = (self%size == 0)

   end function



   subroutine Reserve(self, n)
      class(stdVector), intent(inout) :: self
      integer         , intent(in)    :: n

      ! Requests that the vector capacity be at least enough to contain n elements.
      !
      ! If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing
      ! its capacity to n (or greater).
      !
      ! In all other cases, the function call does not cause a reallocation and the vector capacity is not affected.
      !
      ! This function has no effect on the vector size and cannot alter its elements.

      if (n > self%Capacity()) call self%ChangeCapacity(n)

   end subroutine



   subroutine ShrinkToFit(self)
      class(stdVector), intent(inout) :: self

      ! Requests the container to reduce its capacity to fit its size.
      !
      ! The request is non-binding, and the container implementation is free to optimize otherwise and leave the vector with a
      ! capacity greater than its size.
      !
      ! This may cause a reallocation, but has no effect on the vector size and cannot alter its elements.

      call self%ChangeCapacity(self%size)

   end subroutine



! =============> Element access:

                 ! TODO


! =============> Modifiers:



   subroutine PushBack(self, val)
      class(stdVector), intent(inout) :: self
      real            , intent(in)    :: val

      ! Adds a new element at the end of the vector, after its current last element. The content of val is copied to
      ! the new element.
      !
      ! This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage
      ! space if -and only if- the new vector size surpasses the current vector capacity.

      self%size = self%size + 1
      if (self%size > self%Capacity()) call self%IncreaseCapacity()
      self%data(self%size) = val

   end subroutine



   real function PopBack(self)
      class(stdVector), intent(inout) :: self

      ! Removes the last element in the vector, effectively reducing the container size by one.
      !
      ! This destroys the removed element.

      self%size = self%size - 1
      PopBack = self%data(self%size+1)

   end function



   subroutine InsertSingle(self, position, val)
      class(stdVector), intent(inout) :: self
      integer         , intent(in)    :: position
      real            , intent(in)    :: val

      call self%InsertArray(position, [val])

   end subroutine



   subroutine InsertFill(self, position, n, val)
      class(stdVector), intent(inout) :: self
      integer         , intent(in)    :: position
      integer         , intent(in)    :: n
      real            , intent(in)    :: val

      integer :: i

      call self%InsertArray(position, [(val, i=1,n)])

   end subroutine



   subroutine InsertArray(self, position, array)
      class(stdVector), intent(inout) :: self
      integer         , intent(in)    :: position
      real            , intent(in)    :: array(:)

      integer :: i

      if (size(array) == 0) return

      if (self%size + size(array) > 2 * self%Capacity()) then
         call self%ChangeCapacity(self%size + size(array))
      elseif (self%size + size(array) > self%Capacity()) then
         call self%IncreaseCapacity()
      endif

      self%size = self%size + size(array)

   end subroutine



! =============> Private methods:



   subroutine ChangeCapacity(self, n)
      class(stdVector), intent(inout) :: self
      integer         , intent(in)    :: n

      integer :: numretain
      real, allocatable :: tmp(:)

      if (n /= self%Capacity()) then
         numretain = min(self%size, n)
         if (numretain > 0) then
            allocate(tmp(numretain))
            tmp = self%data(1:numretain)
         endif
         deallocate(self%data)
         allocate(self%data(n))
         if (numretain > 0) then
            self%data(1:numretain) = tmp
            deallocate(tmp)
         endif
      endif

   end subroutine



   subroutine IncreaseCapacity(self)

      class(stdVector), intent(inout) :: self

      call self%changeCapacity(max(2 * self%Capacity(), 1))

   end subroutine



end module

