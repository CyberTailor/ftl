! Vectors are sequence containers representing arrays that can change in size.
!
! Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be
! accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size
! can change dynamically, with their storage being handled automatically by the container.
!
! Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to
! grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a
! relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the
! container.
!
! Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have
! an actual capacity greater than the storage strictly needed to contain its elements (i.e., its size). Libraries can implement
! different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only
! happen at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be
! provided with amortized constant time complexity (see push_back).
!
! Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in
! an efficient way.
!
! Compared to the other dynamic sequence containers (deques, lists and forward_lists), vectors are very efficient accessing its
! elements (just like arrays) and relatively efficient adding or removing elements from its end. For operations that involve
! inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent
! iterators and references than lists and forward_lists.

#define STD_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR


module stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Module

#ifdef STD_TEMPLATE_TYPE_MODULE
   use STD_TEMPLATE_TYPE_MODULE
#endif

   implicit none
   private

! ====== Type of the stdVector container itself ==================================================================================

   type, public :: stdVector/**/STD_TEMPLATE_TYPE_NAME

   private

      integer                                :: psize = 0
      STD_TEMPLATE_TYPE, allocatable         :: storage(:)
      STD_TEMPLATE_TYPE, pointer    , public :: data(:) => null()
      STD_TEMPLATE_TYPE, pointer    , public :: front => null()
      STD_TEMPLATE_TYPE, pointer    , public :: back => null()

   contains

      procedure         :: NewDefault
      procedure         :: NewCopyOther
      procedure         :: NewFill
      procedure         :: NewFromArray
      generic  , public :: New => NewDefault, NewCopyOther, NewFill, NewFromArray

      procedure, public :: Delete

      procedure         :: PrintVector
      generic  , public :: Print => PrintVector

      procedure, public :: Begin
      procedure, public :: End

      procedure         :: SizeVector
      generic  , public :: Size => SizeVector

      procedure, public :: Resize
      procedure, public :: Capacity
      procedure, public :: Empty
      procedure, public :: Reserve
      procedure, public :: ShrinkToFit

      procedure         :: PushBack
      procedure         :: PopBack

      procedure         :: InsertSingle
      procedure         :: InsertFill
      procedure         :: InsertArray
      generic  , public :: Insert => InsertSingle, InsertFill, InsertArray

      procedure         :: EraseSingle
      procedure         :: EraseRange
      generic  , public :: Erase => EraseSingle, EraseRange

      procedure, public :: Clear

      procedure         :: ChangeCapacity
      procedure         :: IncreaseCapacity
      procedure         :: FixValuePtrs

   end type

   public :: Size
   interface Size
      module procedure SizeVector
   end interface

   public :: assignment(=)
   interface assignment(=)
      module procedure AssignArray, AssignOther
   end interface


! ====== Type of an iterator over a stdVector container ==========================================================================

   type, public :: stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator

   private

      STD_TEMPLATE_TYPE, pointer         :: storage(:) => null()
      integer                            :: index = 0
      STD_TEMPLATE_TYPE, pointer, public :: value => null()

   contains

      procedure         :: NewItDefault
      procedure         :: NewItCopyOther
      generic  , public :: New => NewItDefault, NewItCopyOther

      procedure         :: PrintIt
      generic  , public :: Print => PrintIt

      procedure, public :: Inc
      procedure, public :: Dec

   end type

   public :: operator(+)
   interface operator(+)
      module procedure AdvanceN
   end interface

   public :: operator(-)
   interface operator(-)
      module procedure ReverseN, DiffOther
   end interface

   public :: operator(==)
   interface operator(==)
      module procedure EqualOther
   end interface

   public :: operator(/=)
   interface operator(/=)
      module procedure UnequalOther
   end interface

   public :: operator(<)
   interface operator(<)
      module procedure SmallerOther
   end interface

   public :: operator(<=)
   interface operator(<=)
      module procedure SmallerEqualOther
   end interface

   public :: operator(>)
   interface operator(>)
      module procedure GreaterOther
   end interface

   public :: operator(>=)
   interface operator(>=)
      module procedure GreaterEqualOther
   end interface


contains



! ====== Implementation of stdVector methods =====================================================================================


   ! Constructs a vector, initializing its contents depending on the constructor version used:
   !
   subroutine NewDefault(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self

      ! Constructs an empty vector, with no elements.

      allocate(self%storage(0))
      call self%FixValuePtrs()

   end subroutine
   !
   subroutine NewCopyOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in)  :: other

      ! Constructs a vector as a copy of another vector.

      allocate(self%storage(other%psize))
      self%storage = other%storage(1:other%psize)
      self%psize = other%psize
      call self%FixValuePtrs()

   end subroutine
   !
   subroutine NewFill(self, n, val)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out)          :: self
      integer                                   , intent(in)           :: n
      STD_TEMPLATE_TYPE                         , intent(in), optional :: val

      ! Constructs a container with n elements. Each element is a copy of val (if present).

      allocate(self%storage(n))
      if (present(val)) self%storage = val
      self%psize = n
      call self%FixValuePtrs()

   end subroutine
   !
   subroutine NewFromArray(self, array)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self
      STD_TEMPLATE_TYPE                         , intent(in)  :: array(:)

      ! Constructs a container with a copy of each of the elements in arr, in the same order.

      allocate(self%storage(size(array)))
      self%storage = array
      self%psize = size(array)
      call self%FixValuePtrs()

   end subroutine



   subroutine Delete(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self

      ! Nothing to do here: intent(out) will deallocate self%storage and reset self%psize and self%data

   end subroutine



   ! Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.
   !
   subroutine AssignArray(self, array)
      type(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self
      STD_TEMPLATE_TYPE                         , intent(in)  :: array(:)

      ! TODO: more efficient implementation
      call self%NewFromArray(array)

   end subroutine
   !
   subroutine AssignOther(self, other)
      type(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self
      type(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in)  :: other

      ! TODO: more efficient implementation
      call self%NewCopyOther(other)

   end subroutine



   subroutine PrintVector(self, unit_in)
      use, intrinsic :: iso_fortran_env, only: output_unit
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in)           :: self
      integer                                   , intent(in), optional :: unit_in

      integer :: unit

      if (present(unit_in)) then
         unit = unit_in
      else
         unit = output_unit
      endif

      write(unit,*) 'size = ', self%psize
      write(unit,*) 'capacity = ', size(self%storage)
#ifdef STD_TEMPLATE_TYPE_IS_PRINTABLE
      write(unit,*) 'data = ', self%data
      write(unit,*) 'front = ', self%front
      write(unit,*) 'back = ', self%back
#else
      write(unit,*) 'data = [???] (unprintable type)'
      write(unit,*) 'front = [???] (unprintable type)'
      write(unit,*) 'back = [???] (unprintable type)'
#endif

   end subroutine



   ! =============> Iterators:



   ! Returns an iterator pointing to the first element in the vector.
   !
   ! Notice that, unlike member vector%front, which returns a reference to the first element, this function returns a random
   ! access iterator pointing to it.
   !
   ! If the container is empty, the returned iterator value shall not be dereferenced.
   !
   type(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) function Begin(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in), target :: self

      Begin%storage => self%storage
      Begin%index = 1
      Begin%value => self%storage(1)

   end function



   ! Returns an iterator referring to the past-the-end element in the vector container.
   !
   ! The past-the-end element is the theoretical element that would follow the last element in the vector. It does not point
   ! to any element, and thus shall not be dereferenced.
   !
   ! Because the ranges used by functions of the standard library do not include the element pointed by their closing
   ! iterator, this function is often used in combination with vector%begin to specify a range including all the elements in
   ! the container.
   !
   ! If the container is empty, this function returns the same as vector%begin.
   !
   type(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) function End(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in), target :: self

      End%storage => self%storage
      End%index = self%psize + 1
      End%value => self%storage(self%psize + 1)

   end function



   ! =============> Capacity:



   ! Returns the number of elements in the vector.
   !
   ! This is the number of actual objects held in the vector, which is not necessarily equal to its storage capacity.
   !
   pure integer function SizeVector(self) result(Size)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in) :: self

      Size = self%psize

   end function


   ! Resizes the container so that it contains n elements.
   !
   ! If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond
   ! (and destroying them).
   !
   ! If n is greater than the current container size, the content is expanded by inserting at the end as many elements as
   ! needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are
   ! value-initialized.
   !
   ! If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes
   ! place.
   !
   ! Notice that this function changes the actual content of the container by inserting or erasing elements from it.
   !
   subroutine Resize(self, n, val)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout)        :: self
      integer                                   , intent(in)           :: n
      STD_TEMPLATE_TYPE                         , intent(in), optional :: val

      if (n == self%psize) return

      if (n > self%Capacity()) call self%ChangeCapacity(n)
      if (present(val) .and. n > self%psize) self%storage(self%psize+1:n) = val
      ! TODO: call destructor on removed elements when shrinking?
      self%psize = n
      call self%FixValuePtrs()

   end subroutine



   ! Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.
   !
   ! This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to
   ! accommodate for growth without the need to reallocate on each insertion.
   !
   ! Notice that this capacity does not suppose a limit on the size of the vector. When this capacity is exhausted and more is
   ! needed, it is automatically expanded by the container (reallocating it storage space).
   !
   ! The capacity of a vector can be explicitly altered by calling member stdVector%reserve.
   !
   pure integer function Capacity(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in) :: self

      if (allocated(self%storage)) then
         Capacity = size(self%storage)
      else
         Capacity = 0
      endif

   end function



   ! Returns whether the vector is empty (i.e. whether its size is 0).
   !
   ! This function does not modify the container in any way. To clear the content of a vector, see stdVector%clear.
   !
   pure logical function Empty(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(in) :: self

      Empty = (self%psize == 0)

   end function



   ! Requests that the vector capacity be at least enough to contain n elements.
   !
   ! If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing
   ! its capacity to n (or greater).
   !
   ! In all other cases, the function call does not cause a reallocation and the vector capacity is not affected.
   !
   ! This function has no effect on the vector size and cannot alter its elements.
   !
   subroutine Reserve(self, n)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: n

      if (n > self%Capacity()) call self%ChangeCapacity(n)

   end subroutine



   ! Requests the container to reduce its capacity to fit its size.
   !
   ! The request is non-binding, and the container implementation is free to optimize otherwise and leave the vector with a
   ! capacity greater than its size.
   !
   ! This may cause a reallocation, but has no effect on the vector size and cannot alter its elements.
   !
   subroutine ShrinkToFit(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self

      call self%ChangeCapacity(self%psize)

   end subroutine



   ! =============> Modifiers:



   ! Adds a new element at the end of the vector, after its current last element. The content of val is copied to
   ! the new element.
   !
   ! This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage
   ! space if -and only if- the new vector size surpasses the current vector capacity.
   !
   subroutine PushBack(self, val)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      STD_TEMPLATE_TYPE                         , intent(in)    :: val

      self%psize = self%psize + 1
      if (self%psize > self%Capacity()) call self%IncreaseCapacity()
      self%storage(self%psize) = val
      call self%FixValuePtrs()

   end subroutine



   ! Removes the last element in the vector, effectively reducing the container size by one.
   !
   ! This destroys the removed element.
   !
   STD_TEMPLATE_TYPE function PopBack(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self

      PopBack = self%storage(self%psize)
      self%psize = self%psize - 1
      call self%FixValuePtrs()

   end function



   ! The vector is extended by inserting new elements before the element at the specified position, effectively increasing
   ! the container size by the number of elements inserted.  This causes an automatic reallocation of the allocated storage
   ! space if -and only if- the new vector size surpasses the current vector capacity.
   !
   ! Because vectors use an array as their underlying storage, inserting elements in positions other than the vector end
   ! causes the container to relocate all the elements that were after position to their new positions. This is generally an
   ! inefficient operation compared to the one performed for the same operation by other kinds of sequence containers (such
   ! as list or forward_list).
   !
   ! The parameters determine how many elements are inserted and to which values they are initialized:
   !
   subroutine InsertSingle(self, position, val)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: position
      STD_TEMPLATE_TYPE                         , intent(in)    :: val

      call self%InsertArray(position, [val])

   end subroutine
   !
   subroutine InsertFill(self, position, n, val)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: position
      integer                                   , intent(in)    :: n
      STD_TEMPLATE_TYPE                         , intent(in)    :: val

      integer :: i

      if (n == 0) return
      call self%InsertArray(position, [(val, i=1,n)])

   end subroutine
   !
   subroutine InsertArray(self, position, array)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: position
      STD_TEMPLATE_TYPE                         , intent(in)    :: array(:)

      integer :: i

      if (size(array) == 0) return

      if (self%psize + size(array) > 2 * self%Capacity()) then
         call self%ChangeCapacity(self%psize + size(array))
      elseif (self%psize + size(array) > self%Capacity()) then
         call self%IncreaseCapacity()
      endif

      do i = self%psize, position, -1
         self%storage(i+size(array)) = self%storage(i)
      enddo

      self%storage(position:position+size(array)-1) = array

      self%psize = self%psize + size(array)
      call self%FixValuePtrs()

   end subroutine



   ! Removes from the vector either a single element (position) or a range of elements [first,last).
   !
   ! This effectively reduces the container size by the number of elements removed, which are destroyed.
   !
   ! Because vectors use an array as their underlying storage, erasing elements in positions other than the vector end causes
   ! the container to relocate all the elements after the segment erased to their new positions. This is generally an
   ! inefficient operation compared to the one performed for the same operation by other kinds of sequence containers (such
   ! as list or forward_list).
   !
   subroutine EraseSingle(self, position)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: position

      call self%EraseRange(position, position+1)

   end subroutine
   !
   subroutine EraseRange(self, first, last)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: first
      integer                                   , intent(in)    :: last

      integer :: i

      if (last <= first) return

      do i = first, last-1
         ! TODO: call destructor on removed elements?
         self%storage(i) = self%storage(i+last-first)
      enddo

      self%psize = self%psize - (last-first)
      call self%FixValuePtrs()

   end subroutine



   ! Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.
   !
   ! A reallocation is not guaranteed to happen, and the vector capacity is not guaranteed to change due to calling this
   ! function.
   !
   subroutine Clear(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self

      call self%EraseRange(1, self%psize+1)

   end subroutine



   ! =============> Internal methods:



   subroutine FixValuePtrs(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout), target :: self

      self%data => self%storage(1:self%psize)
      self%front => self%storage(1)
      self%back => self%storage(self%psize)

   end subroutine



   subroutine ChangeCapacity(self, n)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      integer                                   , intent(in)    :: n

      STD_TEMPLATE_TYPE, allocatable :: newstorage(:)
      integer :: numretain

      if (n == self%Capacity()) return

      allocate(newstorage(n))

      numretain = min(self%psize, n)
      newstorage(1:numretain) = self%storage(1:numretain)

      call move_alloc(newstorage, self%storage)

   end subroutine



   subroutine IncreaseCapacity(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self

      call self%changeCapacity(max(2 * self%Capacity(), 1))

   end subroutine



! ====== Implementation of stdVectorIterator methods =============================================================================



   subroutine NewItDefault(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(out) :: self

      ! Nothing to do here: intent(out) already resets everything

   end subroutine
   !
   subroutine NewItCopyOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(out) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in)  :: other

      self%storage => other%storage
      self%index =  other%index
      self%value => self%storage(self%index)

   end subroutine



   subroutine PrintIt(self, unit_in)
      use, intrinsic :: iso_fortran_env, only: output_unit
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in)           :: self
      integer                                               , intent(in), optional :: unit_in

      integer :: unit

      if (present(unit_in)) then
         unit = unit_in
      else
         unit = output_unit
      endif

      write(unit,*) 'index = ', self%index
#ifdef STD_TEMPLATE_TYPE_IS_PRINTABLE
      write(unit,*) 'value = ', self%value
#else
      write(unit,*) 'value = [???] (unprintable type)'
#endif

   end subroutine



   ! =============> Arithmetic operations:



   subroutine Inc(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(inout) :: self

      self%index =  self%index + 1
      self%value => self%storage(self%index)

   end subroutine
   !
   subroutine Dec(self)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(inout) :: self

      self%index =  self%index - 1
      self%value => self%storage(self%index)

   end subroutine



   type(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) function AdvanceN(self, n)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      integer                                               , intent(in) :: n

      call AdvanceN%New(self)
      AdvanceN%index =  AdvanceN%index + n
      AdvanceN%value => AdvanceN%storage(AdvanceN%index)

   end function
   !
   type(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) function ReverseN(self, n)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      integer                                               , intent(in) :: n

      call ReverseN%New(self)
      ReverseN%index =  ReverseN%index - n
      ReverseN%value => ReverseN%storage(ReverseN%index)

   end function



   pure integer function DiffOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      if (associated(self%storage,other%storage)) then
         DiffOther = self%index - other%index
      else
         DiffOther = huge(0)
      endif

   end function



   ! =============> Logical operations:



   pure logical function EqualOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      EqualOther = associated(self%storage,other%storage) .and. (self%index == other%index)

   end function
   !
   pure logical function UnequalOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      UnequalOther = .not.associated(self%storage,other%storage) .or. (self%index /= other%index)

   end function
   !
   pure logical function SmallerOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      SmallerOther = associated(self%storage,other%storage) .and. (self%index < other%index)

   end function
   !
   pure logical function SmallerEqualOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      SmallerEqualOther = associated(self%storage,other%storage) .and. (self%index <= other%index)

   end function
   !
   pure logical function GreaterOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      GreaterOther = associated(self%storage,other%storage) .and. (self%index > other%index)

   end function
   !
   pure logical function GreaterEqualOther(self, other)
      class(stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      type (stdVector/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      GreaterEqualOther = associated(self%storage,other%storage) .and. (self%index >= other%index)

   end function


end module
