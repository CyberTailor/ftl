! Copyright (c) 2017  Robert RÃ¼ger
!
! This file is part of of the Fortran Template Library.
!
! The Fortran Template Library is free software: you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public License as
! published by the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! The Fortran Template Library is distributed in the hope that it will be
! useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
! General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public License along
! with the Fortran Template Library.  If not, see <http://www.gnu.org/licenses/>.

#define FTL_CONTAINER ftlDeque
#define FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR

#ifdef FTL_INSTANTIATE_TEMPLATE

#ifndef FTL_DEQUE_PAGESIZE
#define FTL_DEQUE_PAGESIZE 512
#endif

#if !defined(FTL_TEMPLATE_TYPE)
#error FTL_TEMPLATE_TYPE must be defined when instantiating ftlDeque
#endif
#if !defined(FTL_TEMPLATE_TYPE_NAME)
#error FTL_TEMPLATE_TYPE_NAME must be defined when instantiating ftlDeque
#endif

#include "ftlMacros.inc"

#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
#define FTL_TEMPLATE_TYPE_WRAP type(FTL_TEMPLATE_TYPE)
#else
#define FTL_TEMPLATE_TYPE_WRAP FTL_TEMPLATE_TYPE
#endif


module CAT3(ftlDeque,FTL_TEMPLATE_TYPE_NAME,Module)

#ifdef FTL_TEMPLATE_TYPE_MODULE
   use FTL_TEMPLATE_TYPE_MODULE
#endif

   implicit none
   private

! ====== Type of the ftlDeque container itself ===================================================================================

   type :: Page
      FTL_TEMPLATE_TYPE_WRAP, allocatable :: storage(:)
   end type

   type, public :: CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)
      private

      integer                                     :: psize = 0
      integer                                     :: pagesOffset = 0 ! offset for iterator access to pages
      type(Page)            , allocatable         :: pages(:)
      integer                                     :: frontPage = 1, frontIdx = 1
      integer                                     :: backPage  = 1, backIdx  = 0
      FTL_TEMPLATE_TYPE_WRAP, pointer    , public :: front => null()
      FTL_TEMPLATE_TYPE_WRAP, pointer    , public :: back => null()

   contains
      private

      procedure         :: NewDefault
      procedure         :: NewCopyOther
      generic  , public :: New => NewDefault, NewCopyOther

      procedure, public :: Delete
      final             :: Finalizer

      procedure         :: SizeDeque
      generic, public   :: Size => SizeDeque

      procedure, public :: PushFront
      procedure, public :: PopFront
      procedure, public :: PushBack
      procedure, public :: PopBack

      procedure         :: FixValuePtrs
      procedure, public :: DebugPrint
      procedure         :: AddPagesFront
      procedure         :: RemovePagesFront
      procedure         :: AddPagesBack
      procedure         :: RemovePagesBack

   end type

   public :: Size
   interface Size
      module procedure SizeDeque
   end interface


contains



! ====== Implementation of ftlDeque methods ======================================================================================


   subroutine NewDefault(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(out) :: self

      allocate(self%pages(1))
      allocate(self%pages(1)%storage(FTL_DEQUE_PAGESIZE))

   end subroutine
   !
   subroutine NewCopyOther(self, other)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(out) :: self
       type(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(in)  :: other

      self%psize = other%psize
      self%pages = other%pages
      self%frontPage = other%frontPage
      self%backPage  = other%backPage
      self%frontIdx  = other%frontIdx
      self%backIdx   = other%backIdx
      call self%FixValuePtrs()

   end subroutine



   elemental subroutine Delete(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      self%psize = 0
      self%pagesOffset = 0
      if (allocated(self%pages)) deallocate(self%pages)
      nullify(self%front)
      nullify(self%back)

   end subroutine
   !
   elemental subroutine Finalizer(self)
      type(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      call self%Delete()

   end subroutine



   pure integer function SizeDeque(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: self

      SizeDeque = self%psize

   end function



   ! =============> Modifiers:



   subroutine PushBack(self, val)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      FTL_TEMPLATE_TYPE_WRAP                     , intent(in)    :: val

      if (self%backIdx < FTL_DEQUE_PAGESIZE) then ! there is still space on the last page
         self%backIdx = self%backIdx + 1
         self%pages(self%backPage)%storage(self%backIdx) = val
      else ! no space on currently last page
         if (self%backPage == size(self%pages)) then ! no unallocated pages in reserve
            call self%AddPagesBack(max(1,size(self%pages))) ! double number of pages, but at least one more
         endif
         self%backPage = self%backPage + 1
         allocate(self%pages(self%backPage)%storage(FTL_DEQUE_PAGESIZE))
         self%backIdx = 1
         self%pages(self%backPage)%storage(self%backIdx) = val
      endif

      self%psize = self%psize + 1
      call self%FixValuePtrs()

   end subroutine



   FTL_TEMPLATE_TYPE_WRAP function PopBack(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

#ifdef FTL_TEMPLATE_TYPE_PROVIDES_FTLMOVE
      call ftlMove(self%pages(self%backPage)%storage(self%backIdx), PopBack)
#else
      PopBack = self%pages(self%backPage)%storage(self%backIdx)
      call TriggerFinalizer(self%pages(self%backPage)%storage(self%backIdx))
#endif

      if (self%backIdx == 1) then ! we might need to deallocate the last page
         if (self%frontPage == self%backPage) then ! ... but don't deallocate the last remaining page
            self%backIdx = 0
         else
            deallocate(self%pages(self%backPage)%storage)
            self%backPage = self%backPage - 1
            self%backIdx = FTL_DEQUE_PAGESIZE
         endif
      else ! still more stuff on last page
         self%backIdx = self%backIdx - 1
      endif

      self%psize = self%psize - 1
      if (self%backPage < size(self%pages) / 2) call self%RemovePagesBack(self%backPage / 2)
      call self%FixValuePtrs()

   end function



   subroutine PushFront(self, val)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      FTL_TEMPLATE_TYPE_WRAP                     , intent(in)    :: val

      if (self%psize == 0) then
#ifndef NDEBUG
         if (self%frontPage /= self%backPage) stop 'ERROR: frontPage /= backPage in empty ftlDeque'
#endif
         self%pages(self%frontPage)%storage(FTL_DEQUE_PAGESIZE) = val
         self%frontIdx = FTL_DEQUE_PAGESIZE
         self%backIdx  = FTL_DEQUE_PAGESIZE
      else if (self%frontIdx > 1) then ! there is still space on the first page
         self%frontIdx = self%frontIdx - 1
         self%pages(self%frontPage)%storage(self%frontIdx) = val
      else ! no space on currently first page
         if (self%frontPage == 1) then ! no unallocated pages in reserve
            call self%AddPagesFront(max(1,size(self%pages))) ! double number of pages, but at least one more
         endif
         self%frontPage = self%frontPage - 1
         allocate(self%pages(self%frontPage)%storage(FTL_DEQUE_PAGESIZE))
         self%frontIdx = FTL_DEQUE_PAGESIZE
         self%pages(self%frontPage)%storage(self%frontIdx) = val
      endif

      self%psize = self%psize + 1
      call self%FixValuePtrs()

   end subroutine



   FTL_TEMPLATE_TYPE_WRAP function PopFront(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

#ifdef FTL_TEMPLATE_TYPE_PROVIDES_FTLMOVE
      call ftlMove(self%pages(self%frontPage)%storage(self%frontIdx), PopFront)
#else
      PopFront = self%pages(self%frontPage)%storage(self%frontIdx)
      call TriggerFinalizer(self%pages(self%frontPage)%storage(self%frontIdx))
#endif

      if (self%frontIdx == FTL_DEQUE_PAGESIZE) then ! we might need to deallocate the first page
         if (self%frontPage == self%backPage) then ! ... but don't deallocate the last remaining page
            self%frontIdx = 1
            self%backIdx  = 0
         else
            deallocate(self%pages(self%frontPage)%storage)
            self%frontPage = self%frontPage + 1
            self%frontIdx  = 1
         endif
      else ! still more stuff on last page
         self%frontIdx = self%frontIdx + 1
      endif

      self%psize = self%psize - 1
      if (self%frontPage > size(self%pages) / 2) call self%RemovePagesFront(self%frontPage / 2)
      call self%FixValuePtrs()

   end function



   ! =============> Internal methods:



   subroutine FixValuePtrs(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout), target :: self

      if (self%psize == 0) then
         ! not strictly necessary, because it will always crash if someone accesses front/back on an empty dynArray ...
         nullify(self%front, self%back)
      else
         self%front => self%pages(self%frontPage)%storage(self%frontIdx)
         self%back  => self%pages(self%backPage)%storage(self%backIdx)
      endif

   end subroutine



   subroutine DebugPrint(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      integer :: p

      write (*,*) 'size =', self%psize
      write (*,*) 'frontPage =', self%frontPage
      write (*,*) 'frontIdx =', self%frontIdx
      write (*,*) 'backPage =', self%backPage
      write (*,*) 'backIdx =', self%backIdx
      write (*,*) 'pagesOffset =', self%pagesOffset

      if (allocated(self%pages)) then
         do p = 1, size(self%pages)
            if (allocated(self%pages(p)%storage)) then
               if (p == self%frontPage .and. p == self%backPage) then
                  write (*,*) 'Page ', p, ':', self%pages(p)%storage(self%frontIdx:self%backIdx)
               else if (p == self%frontPage) then
                  write (*,*) 'Page ', p, ':', self%pages(p)%storage(self%frontIdx:)
               else if (p == self%backPage) then
                  write (*,*) 'Page ', p, ':', self%pages(p)%storage(:self%backIdx)
               else
                  write (*,*) 'Page ', p, ':', self%pages(p)%storage
               endif
            else
               write (*,*) 'Page ', p, ' is not allocated'
            endif
         enddo
      else
         write (*,*) 'Pages not allocated'
      endif

   end subroutine



   subroutine AddPagesFront(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

      allocate(newpage(size(self%pages)+n))
      do p = 1, size(self%pages)
         call move_alloc(self%pages(p)%storage, newpage(p+n)%storage)
      enddo
      call move_alloc(newpage, self%pages)

      self%frontPage   = self%frontPage   + n
      self%backPage    = self%backPage    + n
      self%pagesOffset = self%pagesOffset + n

   end subroutine
   !
   subroutine RemovePagesFront(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

#ifndef NDEBUG
      do p = 1, n
         if (allocated(self%pages(p)%storage)) then
            stop 'ERROR: Removing allocated pages in ftlDeque%RemovePagesFront'
         endif
      enddo
#endif

      allocate(newpage(size(self%pages)-n))
      do p = 1, size(newpage)
         call move_alloc(self%pages(p+n)%storage, newpage(p)%storage)
      enddo
      call move_alloc(newpage, self%pages)

      self%frontPage  = self%frontPage  - n
      self%backPage   = self%backPage   - n
      self%pagesOffset = self%pagesOffset - n

   end subroutine
   !
   subroutine AddPagesBack(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout), target :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

      allocate(newpage(size(self%pages)+n))
      do p = 1, size(self%pages)
         call move_alloc(self%pages(p)%storage, newpage(p)%storage)
      enddo
      call move_alloc(newpage, self%pages)

   end subroutine
   !
   subroutine RemovePagesBack(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

#ifndef NDEBUG
      do p = size(self%pages)-n+1, size(self%pages)
         if (allocated(self%pages(p)%storage)) then
            stop 'ERROR: Removing allocated pages in ftlDeque%RemovePagesBack'
         endif
      enddo
#endif

      allocate(newpage(size(self%pages)-n))
      do p = 1, size(newpage)
         call move_alloc(self%pages(p)%storage, newpage(p)%storage)
      enddo
      call move_alloc(newpage, self%pages)

   end subroutine



   elemental subroutine TriggerFinalizer(instance)
      FTL_TEMPLATE_TYPE_WRAP, intent(out) :: instance

      ! Nothing to do here: intent(out) will finalize the instance and that's all we want

   end subroutine


end module
#endif
