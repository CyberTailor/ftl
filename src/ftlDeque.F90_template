! Copyright (c) 2017  Robert RÃ¼ger
!
! This file is part of of the Fortran Template Library.
!
! The Fortran Template Library is free software: you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public License as
! published by the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! The Fortran Template Library is distributed in the hope that it will be
! useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
! General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public License along
! with the Fortran Template Library.  If not, see <http://www.gnu.org/licenses/>.

#define FTL_CONTAINER ftlDeque
#define FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR

#ifdef FTL_INSTANTIATE_TEMPLATE

#ifndef FTL_DEQUE_PAGESIZE
#define FTL_DEQUE_PAGESIZE 512
#endif

#if !defined(FTL_TEMPLATE_TYPE)
#error FTL_TEMPLATE_TYPE must be defined when instantiating ftlDeque
#endif
#if !defined(FTL_TEMPLATE_TYPE_NAME)
#error FTL_TEMPLATE_TYPE_NAME must be defined when instantiating ftlDeque
#endif

#include "ftlMacros.inc"

#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
#define FTL_TEMPLATE_TYPE_WRAP type(FTL_TEMPLATE_TYPE)
#else
#define FTL_TEMPLATE_TYPE_WRAP FTL_TEMPLATE_TYPE
#endif


module CAT3(ftlDeque,FTL_TEMPLATE_TYPE_NAME,Module)

#ifdef FTL_TEMPLATE_TYPE_MODULE
   use FTL_TEMPLATE_TYPE_MODULE
#endif

   implicit none
   private

! ====== Type of the ftlDeque container itself ===================================================================================

   type :: Page
      FTL_TEMPLATE_TYPE_WRAP, allocatable :: storage(:)
   end type

   type, public :: CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)
      private

      integer                                     :: psize = 0
      integer                                     :: pageOffset = 0 ! offset for iterator access to pages
      type(Page)            , allocatable         :: page(:)
      integer                                     :: firstPage, lastPage ! first and last (inclusive) page in use
      integer                                     :: frontIdx ! index of front within first page
      integer                                     :: backIdx  ! index of back  within last  page
      FTL_TEMPLATE_TYPE_WRAP, pointer    , public :: front => null()
      FTL_TEMPLATE_TYPE_WRAP, pointer    , public :: back => null()

   contains
      private

      procedure         :: NewDefault
      procedure         :: NewCopyOther
      generic  , public :: New => NewDefault, NewCopyOther

      procedure, public :: Delete
      final             :: Finalizer

      procedure         :: FixValuePtrs

   end type


contains



! ====== Implementation of ftlDeque methods ======================================================================================


   subroutine NewDefault(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(out) :: self

      allocate(self%page(1))
      allocate(self%page(1)%storage(FTL_DEQUE_PAGESIZE))
      self%firstPage = 1
      self%lastPage  = 1
      self%frontIdx  = 1
      self%backIdx   = 0

   end subroutine
   !
   subroutine NewCopyOther(self, other)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(out) :: self
       type(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(in)  :: other

      self%psize = other%psize
      self%page = other%page
      self%firstPage = other%firstPage
      self%lastPage  = other%lastPage
      self%frontIdx  = other%frontIdx
      self%backIdx   = other%backIdx
      call self%FixValuePtrs()

   end subroutine



   elemental subroutine Delete(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      self%psize = 0
      self%pageOffset = 0
      if (allocated(self%page)) deallocate(self%page)
      nullify(self%front)
      nullify(self%back)

   end subroutine
   !
   elemental subroutine Finalizer(self)
      type(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      call self%Delete()

   end subroutine



   ! =============> Internal methods:



   subroutine FixValuePtrs(self)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout), target :: self

      if (self%psize == 0) then
         ! not strictly necessary, because it will always crash if someone accesses front/back on an empty dynArray ...
         nullify(self%front, self%back)
      else
         self%front => self%page(self%firstPage)%storage(self%frontIdx)
         self%back  => self%page(self%lastPage)%storage(self%backIdx)
      endif

   end subroutine



   subroutine AddPagesFront(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

      allocate(newpage(size(self%page)+n))
      do p = 1, size(self%page)
         call move_alloc(self%page(p)%storage, newpage(n+p)%storage)
      enddo
      call move_alloc(newpage, self%page)

      self%firstPage  = self%firstPage  + n
      self%lastPage   = self%lastPage   + n
      self%pageOffset = self%pageOffset + n

   end subroutine
   !
   subroutine RemovePagesFront(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

#ifndef NDEBUG
      do p = 1, n
         if (allocated(self%page(p)%storage)) then
            stop 'ERROR: Removing allocated pages in ftlDeque%RemovePagesFront'
         endif
      enddo
#endif

      allocate(newpage(size(self%page)-n))
      do p = 1, size(newpage)
         call move_alloc(self%page(p+n)%storage, newpage(p)%storage)
      enddo
      call move_alloc(newpage, self%page)

      self%firstPage  = self%firstPage  - n
      self%lastPage   = self%lastPage   - n
      self%pageOffset = self%pageOffset - n

   end subroutine
   !
   subroutine AddPagesBack(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout), target :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

      allocate(newpage(size(self%page)+n))
      do p = 1, size(self%page)
         call move_alloc(self%page(p)%storage, newpage(p)%storage)
      enddo
      call move_alloc(newpage, self%page)

   end subroutine
   !
   subroutine RemovePagesBack(self, n)
      class(CAT(ftlDeque,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      integer                                    , intent(in)    :: n

      integer :: p
      type(Page), allocatable :: newpage(:)

#ifndef NDEBUG
      do p = size(self%page)-n+1, size(self%page)
         if (allocated(self%page(p)%storage)) then
            stop 'ERROR: Removing allocated pages in ftlDeque%RemovePagesBack'
         endif
      enddo
#endif

      allocate(newpage(size(self%page)-n))
      do p = 1, size(newpage)
         call move_alloc(self%page(p)%storage, newpage(p)%storage)
      enddo
      call move_alloc(newpage, self%page)

   end subroutine



end module
#endif
