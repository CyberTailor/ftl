! The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating)
! that operate on ranges of elements. Note that a range is defined as [first, last) where last refers to the element past
! the last element to inspect or modify.
!
! A range is any sequence of objects that can be accessed through iterators or pointers, such as an array or an instance
! of some of the FTL containers. Notice though, that algorithms operate through iterators directly on the values, not
! affecting in any way the structure of any possible container (it never affects the size or storage allocation of the
! container).

#ifdef FTL_INSTANTIATE_TEMPLATE

#if !defined(FTL_TEMPLATE_TYPE)
#error FTL_TEMPLATE_TYPE must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_TEMPLATE_TYPE_NAME)
#error FTL_TEMPLATE_TYPE_NAME must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_CONTAINER)
#error FTL_CONTAINER must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_CONTAINER_PROVIDES_FORWARD_ITERATOR)       && \
    !defined(FTL_CONTAINER_PROVIDES_BIDIRECTIONAL_ITERATOR) && \
    !defined(FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR)
#error FTL_CONTAINER_PROVIDES_*_INTERATOR must be defined when instantiating ftlAlgorithms
#endif


module FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/AlgorithmsModule

#ifdef FTL_TEMPLATE_TYPE_MODULE
   use FTL_TEMPLATE_TYPE_MODULE
#endif
   use FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Module

   implicit none
   private


   ! =============> Non-modifying sequence operations:

   public :: ftlAllOf
   interface ftlAllOf
      module procedure ftlAllOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair
      module procedure ftlAllOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME
   end interface

   public :: ftlAnyOf
   interface ftlAnyOf
      module procedure ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair
      module procedure ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME
   end interface

   public :: ftlNoneOf
   interface ftlNoneOf
      module procedure ftlNoneOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair
      module procedure ftlNoneOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME
   end interface

   public :: ftlCount
   interface ftlCount
      module procedure ftlCount/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair
      module procedure ftlCount/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME
   end interface

   public :: ftlCountIf
   interface ftlCountIf
      module procedure ftlCountIf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair
      module procedure ftlCountIf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME
   end interface


   ! =============> Sorting operations:

   public :: ftlSort
   interface ftlSort
      module procedure ftlSort/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME
   end interface



   abstract interface

      logical function UnaryPredicate(a)
         FTL_TEMPLATE_TYPE, intent(in) :: a
      end function

      logical function Comparator(a, b)
         FTL_TEMPLATE_TYPE, intent(in) :: a, b
      end function

   end interface


contains



   ! =============> Non-modifying sequence operations:


   ! Returns true if pred returns true for all the elements in the range [first,last) or if the range is empty,
   ! and false otherwise.
   !
   logical function ftlAllOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(first, last, pred) result(alltrue)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator) :: it

      alltrue = .true.
      it = first
      do while (it /= last)
         if (.not.pred(it%value)) then
            alltrue = .false.
            exit
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlAllOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME(container, pred) result(alltrue)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME), intent(in) :: container
      procedure(UnaryPredicate)                                 :: pred

      alltrue = ftlAllOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Returns true if pred returns true for any of the elements in the range [first,last), and false otherwise.
   !
   ! If [first,last) is an empty range, the function returns false.
   !
   logical function ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(first, last, pred) result(anytrue)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator) :: it

      anytrue = .false.
      it = first
      do while (it /= last)
         if (pred(it%value)) then
            anytrue = .true.
            exit
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME(container, pred) result(anytrue)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME), intent(in) :: container
      procedure(UnaryPredicate)                                 :: pred

      anytrue = ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(container%Begin(), container%End(), pred)

   end function


   ! Returns true if pred returns false for all the elements in the range [first,last) or if the range is empty,
   ! and false otherwise.
   !
   logical function ftlNoneOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(first, last, pred) result(nonetrue)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      nonetrue = .not.ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(first, last, pred)

   end function
   !
   logical function ftlNoneOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME(container, pred) result(nonetrue)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME), intent(in) :: container
      procedure(UnaryPredicate)                                 :: pred

      nonetrue = .not.ftlAnyOf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Returns the number of elements in the range [first,last) that compare equal to val.
   !
   ! The function uses the == operator to compare the individual elements to val.
   !
   integer function ftlCount/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(first, last, val) result(num)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: first, last
      FTL_TEMPLATE_TYPE                                        , intent(in) :: val

      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator) :: it

      num = 0
      it = first
      do while (it /= last)
         if (it%value == val) num = num + 1
         call it%Inc()
      enddo

   end function
   !
   integer function ftlCount/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME(container, val) result(num)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME), intent(in) :: container
      FTL_TEMPLATE_TYPE                            , intent(in) :: val

      num = ftlCount/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(container%Begin(), container%End(), val)

   end function




   ! Returns the number of elements in the range [first,last) for which pred is true.
   !
   integer function ftlCountIf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(first, last, pred) result(num)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator) :: it

      num = 0
      it = first
      do while (it /= last)
         if (pred(it%value)) num = num + 1
         call it%Inc()
      enddo

   end function
   !
   integer function ftlCountIf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME(container, pred) result(num)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME), intent(in) :: container
      procedure(UnaryPredicate)                                 :: pred

      num = ftlCountIf/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/IteratorPair(container%Begin(), container%End(), pred)

   end function



   ! =============> Sorting operations:



   subroutine ftlSort/**/FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME(container, comp)
      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME), intent(inout) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional :: comp
#else
      procedure(Comparator)           :: comp
#endif

      type(FTL_CONTAINER/**/FTL_TEMPLATE_TYPE_NAME/**/Iterator) :: i, j, smallestIt
      FTL_TEMPLATE_TYPE :: tmp

      ! TODO: implement something faster than selection sort ;-) ...

      j = container%Begin()
      do while (j /= container%End())
         smallestIt = j
         i = j
         call i%Inc()
         do while (i /= container%End())
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
            if (present(comp)) then
               if (comp(i%value, smallestIt%value)) smallestIt = i
            else
               if (i%value < smallestIt%value) smallestIt = i
            endif
#else
            if (comp(i%value, smallestIt%value)) smallestIt = i
#endif
            call i%Inc()
         enddo
         tmp = j%value
         j%value = smallestIt%value
         smallestIt%value = tmp
         call j%Inc()
      enddo

   end subroutine

end module
#endif
