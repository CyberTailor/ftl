! The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating)
! that operate on ranges of elements. Note that a range is defined as [first, last) where last refers to the element past
! the last element to inspect or modify.
!
! A range is any sequence of objects that can be accessed through iterators or pointers, such as an array or an instance
! of some of the FTL containers. Notice though, that algorithms operate through iterators directly on the values, not
! affecting in any way the structure of any possible container (it never affects the size or storage allocation of the
! container).

#ifdef FTL_INSTANTIATE_TEMPLATE

#if !defined(FTL_TEMPLATE_TYPE)
#error FTL_TEMPLATE_TYPE must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_TEMPLATE_TYPE_NAME)
#error FTL_TEMPLATE_TYPE_NAME must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_CONTAINER)
#error FTL_CONTAINER must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_CONTAINER_PROVIDES_FORWARD_ITERATOR)       && \
    !defined(FTL_CONTAINER_PROVIDES_BIDIRECTIONAL_ITERATOR) && \
    !defined(FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR)
#error FTL_CONTAINER_PROVIDES_*_INTERATOR must be defined when instantiating ftlAlgorithms
#endif

#include "ftlMacros.inc"


module CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,AlgorithmsModule)

#ifdef FTL_TEMPLATE_TYPE_MODULE
   use FTL_TEMPLATE_TYPE_MODULE
#endif
   use CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Module)

   implicit none
   private


   ! =============> Non-modifying sequence operations:

   public :: ftlAllOf
   interface ftlAllOf
      module procedure ftlAllOfIteratorPair
      module procedure ftlAllOfContainer
   end interface

   public :: ftlAnyOf
   interface ftlAnyOf
      module procedure ftlAnyOfIteratorPair
      module procedure ftlAnyOfContainer
   end interface

   public :: ftlNoneOf
   interface ftlNoneOf
      module procedure ftlNoneOfIteratorPair
      module procedure ftlNoneOfContainer
   end interface

   public :: ftlForEach
   interface ftlForEach
      module procedure ftlForEachIteratorPair
      module procedure ftlForEachContainer
   end interface

   public :: ftlFind
   interface ftlFind
      module procedure ftlFindIteratorPair
      module procedure ftlFindContainer
   end interface

   public :: ftlFindIf
   interface ftlFindIf
      module procedure ftlFindIfIteratorPair
      module procedure ftlFindIfContainer
   end interface

   public :: ftlFindIfNot
   interface ftlFindIfNot
      module procedure ftlFindIfNotIteratorPair
      module procedure ftlFindIfNotContainer
   end interface

   ! TODO: ftlFindEnd

   public :: ftlFirstOf
   interface ftlFirstOf
      module procedure ftlFirstOfIteratorPair
      module procedure ftlFirstOfContainer
   end interface

   ! TODO: ftlAdjacentFind

   public :: ftlCount
   interface ftlCount
      module procedure ftlCountIteratorPair
      module procedure ftlCountContainer
   end interface

   public :: ftlCountIf
   interface ftlCountIf
      module procedure ftlCountIfIteratorPair
      module procedure ftlCountIfContainer
   end interface

   public :: ftlMismatch
   interface ftlMismatch
      module procedure ftlMismatchIterators
      module procedure ftlMismatchContainers
   end interface

   ! TODO: ftlEqual

   public :: ftlIsPermutation
   interface ftlIsPermutation
      module procedure ftlIsPermutationIterators
      module procedure ftlIsPermutationContainers
   end interface

   public :: ftlSearch
   interface ftlSearch
      module procedure ftlSearchIterators
      module procedure ftlSearchContainers
   end interface

   ! TODO: ftlSearchN


   ! =============> Modifying sequence operations:

   public :: ftlIterSwap
   interface ftlIterSwap
      module procedure ftlIterSwapPrivate
   end interface


   ! =============> Sorting operations:

   public :: ftlSort
   interface ftlSort
      module procedure ftlSortContainer
   end interface


   ! =============> Iterator operations:
   ! (in C++ these are in the <iterator> header, not in <algorithm>)

   public :: ftlAdvance
   interface ftlAdvance
      module procedure ftlAdvancePrivate
   end interface

   public :: ftlDistance
   interface ftlDistance
      module procedure ftlDistancePrivate
   end interface


   ! =============> Interfaces for dummy procedures:

   abstract interface

      logical function UnaryPredicate(a)
         FTL_TEMPLATE_TYPE, intent(in) :: a
      end function

      logical function Comparator(a, b)
         FTL_TEMPLATE_TYPE, intent(in) :: a, b
      end function

      subroutine UnarySubroutine(a)
         FTL_TEMPLATE_TYPE, intent(inout) :: a
      end subroutine

   end interface


contains



   ! =============> Non-modifying sequence operations:



   ! Returns true if pred returns true for all the elements in the range [first,last) or if the range is empty,
   ! and false otherwise.
   !
   logical function ftlAllOfIteratorPair(first, last, pred) result(alltrue)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      alltrue = .true.
      it = first
      do while (it /= last)
         if (.not.pred(it%value)) then
            alltrue = .false.
            exit
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlAllOfContainer(container, pred) result(alltrue)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container
      procedure(UnaryPredicate)                                   :: pred

      alltrue = ftlAllOfIteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Returns true if pred returns true for any of the elements in the range [first,last), and false otherwise.
   !
   ! If [first,last) is an empty range, the function returns false.
   !
   logical function ftlAnyOfIteratorPair(first, last, pred) result(anytrue)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      anytrue = .false.
      it = first
      do while (it /= last)
         if (pred(it%value)) then
            anytrue = .true.
            exit
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlAnyOfContainer(container, pred) result(anytrue)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container
      procedure(UnaryPredicate)                                   :: pred

      anytrue = ftlAnyOfIteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Returns true if pred returns false for all the elements in the range [first,last) or if the range is empty,
   ! and false otherwise.
   !
   logical function ftlNoneOfIteratorPair(first, last, pred) result(nonetrue)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      nonetrue = .not.ftlAnyOfIteratorPair(first, last, pred)

   end function
   !
   logical function ftlNoneOfContainer(container, pred) result(nonetrue)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container
      procedure(UnaryPredicate)                                 :: pred

      nonetrue = .not.ftlAnyOfIteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Calls subroutine subr on each of the elements in the range [first,last).
   !
   subroutine ftlForEachIteratorPair(first, last, subr)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnarySubroutine)                                            :: subr

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      it = first
      do while (it /= last)
         call subr(it%value)
         call it%Inc()
      enddo

   end subroutine
   !
   subroutine ftlForEachContainer(container, subr)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container
      procedure(UnarySubroutine)                                  :: subr

      call ftlForEachIteratorPair(container%Begin(), container%End(), subr)

   end subroutine



   ! Returns an iterator to the first element in the range [first,last) that compares equal to val. If no such element is
   ! found, the function returns last.
   !
   ! The function uses operator== to compare the individual elements to val.
   !
   function ftlFindIteratorPair(first, last, val) result(it)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      FTL_TEMPLATE_TYPE                                        , intent(in) :: val
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it

      it = first
      do while (it /= last)
         if (it%value == val) exit
         call it%Inc()
      enddo

   end function
   !
   function ftlFindContainer(container, val) result(it)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))          , intent(in) :: container
      FTL_TEMPLATE_TYPE                                        , intent(in) :: val
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it

      it = ftlFindIteratorPair(container%Begin(), container%End(), val)

   end function



   ! Returns an iterator to the first element in the range [first,last) for which pred returns true. If no such element is
   ! found, the function returns last.
   !
   function ftlFindIfIteratorPair(first, last, pred) result(it)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it

      it = first
      do while (it /= last)
         if (pred(it%value)) exit
         call it%Inc()
      enddo

   end function
   !
   function ftlFindIfContainer(container, pred) result(it)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))          , intent(in) :: container
      procedure(UnaryPredicate)                                             :: pred
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it

      it = ftlFindIfIteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Returns an iterator to the first element in the range [first,last) for which pred returns false. If no such element
   ! is found, the function returns last.
   !
   function ftlFindIfNotIteratorPair(first, last, pred) result(it)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it

      it = first
      do while (it /= last)
         if (.not.pred(it%value)) exit
         call it%Inc()
      enddo

   end function
   !
   function ftlFindIfNotContainer(container, pred) result(it)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))          , intent(in) :: container
      procedure(UnaryPredicate)                                             :: pred
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it

      it = ftlFindIfNotIteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Returns an iterator to the first element in the range [first1,last1) that matches any of the elements in [first2,last2).
   ! If no such element is found, the function returns last1.
   !
   ! The elements in [first1,last1) are sequentially compared to each of the values in [first2,last2) using operator== (or
   ! comp, if present), until a pair matches.
   !
   function ftlFirstOfIteratorPair(first1, last1, first2, last2, comp) result(firstOf)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first1, last1, first2, last2
      procedure(Comparator)                                    , optional   :: comp
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: firstOf

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      if (first2 == last2) then
         firstOf = last1
         return
      endif

      firstOf = first1
      do while (firstOf /= last1)
         it = first2
         do while (it /= last2)
            if (present(comp)) then
               if (comp(firstOf%value, it%value)) return
            else
               if (firstOf%value == it%value) return
            endif
            call it%Inc()
         enddo
         call firstOf%Inc()
      enddo

   end function
   !
   function ftlFirstOfContainer(container1, container2, comp) result(firstOf)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))          , intent(in) :: container1, container2
      procedure(Comparator)                                    , optional   :: comp
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: firstOf

      firstOf = ftlFirstOfIteratorPair(container1%Begin(), container1%End(), container2%Begin(), container2%End(), comp)

   end function


   ! Returns the number of elements in the range [first,last) that compare equal to val.
   !
   ! The function uses the == operator to compare the individual elements to val.
   !
   integer function ftlCountIteratorPair(first, last, val) result(num)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      FTL_TEMPLATE_TYPE                                        , intent(in) :: val

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      num = 0
      it = first
      do while (it /= last)
         if (it%value == val) num = num + 1
         call it%Inc()
      enddo

   end function
   !
   integer function ftlCountContainer(container, val) result(num)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container
      FTL_TEMPLATE_TYPE                              , intent(in) :: val

      num = ftlCountIteratorPair(container%Begin(), container%End(), val)

   end function



   ! Returns the number of elements in the range [first,last) for which pred is true.
   !
   integer function ftlCountIfIteratorPair(first, last, pred) result(num)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first, last
      procedure(UnaryPredicate)                                             :: pred

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      num = 0
      it = first
      do while (it /= last)
         if (pred(it%value)) num = num + 1
         call it%Inc()
      enddo

   end function
   !
   integer function ftlCountIfContainer(container, pred) result(num)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container
      procedure(UnaryPredicate)                                   :: pred

      num = ftlCountIfIteratorPair(container%Begin(), container%End(), pred)

   end function



   ! Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns the
   ! first element of both sequences that does not match.
   !
   ! The elements are compared using operator== or comp (if present).
   !
   ! The function returns a pair of iterators to the first element in each range that does not match.
   !
   function ftlMismatchIterators(first1, last1, first2, comp) result(it)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first1, last1, first2
      procedure(Comparator)                                    , optional   :: comp
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it(2)

      it(1) = first1
      it(2) = first2
      do while (it(1) /= last1)
         if (present(comp)) then
            if (.not.comp(it(1)%value,it(2)%value)) exit
         else
            if (it(1)%value /= it(2)%value) exit
         endif
         call it(1)%Inc()
         call it(2)%Inc()
      enddo

   end function
   !
   function ftlMismatchContainers(container1, container2, comp) result(it)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))          , intent(in) :: container1, container2
      procedure(Comparator)                                    , optional   :: comp
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: it(2)

      it = ftlMismatchIterators(container1%Begin(), container1%End(), container2%Begin(), comp)

   end function



   ! Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns true if all of the
   ! elements in both ranges match, even in a different order.
   !
   ! The elements are compared using operator==.
   !
   logical function ftlIsPermutationIterators(first1, last1, first2) result(isPermutation)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first1, last1, first2

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: firstdiff(2), last2, it1
      integer :: n

      isPermutation = .true.

      ! check if sequences are identical or at least have a common beginning (which we would ignore later)
      firstdiff = ftlMismatchIterators(first1, last1, first2)
      if (firstdiff(1) == last1) return

      ! get an iterator to the end of range 2
      last2 = firstdiff(2)
      last2 = ftlAdvance(last2, ftlDistance(firstdiff(1), last1))

      it1 = firstdiff(1)
      do while (it1 /= last1)

         if (ftlFind(firstdiff(1), it1, it1%value) == it1) then ! this is the first time we see it1%value
            n = ftlCount(firstdiff(2), last2, it1%value)
            if (n == 0) then ! it1%value is not anywhere in range 2
               isPermutation = .false.
               return
            endif
            if (n /= ftlCount(firstdiff(1), last1, it1%value)) then ! count of it1%value is different in range 1 and range 2
               isPermutation = .false.
               return
            endif
         endif

         call it1%Inc()
      enddo

   end function
   !
   logical function ftlIsPermutationContainers(container1, container2) result(isPermutation)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: container1, container2

      if (container1%Size() /= container2%Size()) then
         isPermutation = .false.
      else
         isPermutation = ftlIsPermutationIterators(container1%Begin(), container1%End(), container2%Begin())
      endif

   end function



   ! Searches the range [first1,last1) for the first occurrence of the sequence defined by [first2,last2), and returns an
   ! iterator to its first element, or last1 if no occurrences are found.
   !
   ! The elements in both ranges are compared sequentially using operator== (or comp, if present): A subsequence of
   ! [first1,last1) is considered a match only when this is true for _all_ the elements of [first2,last2).
   !
   ! This function returns the first of such occurrences. For an algorithm that returns the last instead, see ftlFindEnd.
   !
   function ftlSearchIterators(first1, last1, first2, last2, comp) result(itFirst)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: first1, last1, first2, last2
      procedure(Comparator)                                    , optional   :: comp
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: itFirst

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it1, it2

      itFirst = first1
      if (first2 == last2) return ! specified by C++11

      do while (itFirst /= last1)
         it1 = itFirst
         it2 = first2
         do while (.true.)
            if (present(comp)) then
               if (.not.comp(it1%value, it2%value)) exit
            else
               if (it1%value /= it2%value) exit
            endif
            call it1%Inc()
            call it2%Inc()
            if (it2 == last2) return ! complete sequence found
            if (it1 == last1) then ! at the end of [first1,last1) but [first2,last2) sequence not complete yet
               itFirst = last1
               return
            endif
         enddo
         call itFirst%Inc()
      enddo

   end function
   !
   function ftlSearchContainers(container1, container2, comp) result(itFirst)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))          , intent(in) :: container1, container2
      procedure(Comparator)                                    , optional   :: comp
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: itFirst

      if (container1%Size() < container2%Size()) then
         itFirst = container1%End()
      else
         itFirst = ftlSearchIterators(container1%Begin(), container1%End(), container2%Begin(), container2%End(), comp)
      endif

   end function



   ! =============> Modifying sequence operations:



   subroutine ftlIterSwapPrivate(it1,it2)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it1, it2

      FTL_TEMPLATE_TYPE :: tmp

      tmp = it1%value
      it1%value = it2%value
      it2%value = tmp

   end subroutine



   ! =============> Sorting operations:



   subroutine ftlSortContainer(container, comp)
      type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional :: comp
#else
      procedure(Comparator)           :: comp
#endif

      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: i, j, smallestIt

      ! TODO: implement something faster than selection sort ;-) ...

      j = container%Begin()
      do while (j /= container%End())
         smallestIt = j
         i = j
         call i%Inc()
         do while (i /= container%End())
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
            if (present(comp)) then
               if (comp(i%value, smallestIt%value)) smallestIt = i
            else
               if (i%value < smallestIt%value) smallestIt = i
            endif
#else
            if (comp(i%value, smallestIt%value)) smallestIt = i
#endif
            call i%Inc()
         enddo
         call ftlIterSwap(j, smallestIt)
         call j%Inc()
      enddo

   end subroutine



   ! =============> Iterator operations:



   function ftlAdvancePrivate(itin, n) result(itout)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: itin
      integer                                                  , intent(in) :: n
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))             :: itout

#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
      itout = itin + n
#else
      integer :: i

      itout = itin
      do i = 1, n
         call itout%Inc()
      enddo
#endif

   end function



   integer function ftlDistancePrivate(it1, it2) result(dist)
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)), intent(in) :: it1, it2

#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
      dist = it2 - it1
#else
      type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator)) :: it

      dist = 0
      it = it1
      do while (it /= it2)
         dist = dist + 1
         call it%Inc()
      enddo
#endif

   end function


end module
#endif
