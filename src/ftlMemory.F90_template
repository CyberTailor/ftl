! Copyright (c) 2016, 2017  Robert RÃ¼ger
!
! This file is part of of the Fortran Template Library.
!
! The Fortran Template Library is free software: you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public License as
! published by the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! The Fortran Template Library is distributed in the hope that it will be
! useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
! General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public License along
! with the Fortran Template Library.  If not, see <http://www.gnu.org/licenses/>.


!   ftlMemory
!   =========
!
! This header defines general utilities to manage dynamic memory.

#ifdef FTL_INSTANTIATE_TEMPLATE

#if !defined(FTL_TEMPLATE_TYPE)
#error FTL_TEMPLATE_TYPE must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_TEMPLATE_TYPE_NAME)
#error FTL_TEMPLATE_TYPE_NAME must be defined when instantiating ftlAlgorithms
#endif

#include "ftlMacros.inc"

#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
#define FTL_TEMPLATE_TYPE_WRAP type(FTL_TEMPLATE_TYPE)
#else
#define FTL_TEMPLATE_TYPE_WRAP FTL_TEMPLATE_TYPE
#endif


module CAT3(ftlMemory,FTL_TEMPLATE_TYPE_NAME,Module)

#ifdef FTL_TEMPLATE_TYPE_MODULE
   use FTL_TEMPLATE_TYPE_MODULE
#endif

   implicit none
   private

   type, public :: CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)
      private

      FTL_TEMPLATE_TYPE_WRAP, pointer, public :: value => null()
      integer               , pointer         :: refcount => null()

   contains
      private

      procedure         :: NewDefault
      procedure         :: NewFromRawPtr
      procedure         :: NewFromOther
      generic  , public :: New => NewDefault, NewFromRawPtr, NewFromOther

      generic  , public :: assignment(=) => NewFromOther

      procedure, public :: Delete
      procedure, public :: Nullify => Delete
      final             :: Finalizer

      procedure, public :: Swap
      procedure, public :: UseCount
      procedure, public :: Unique

   end type

   public :: associated
   interface associated
      module procedure AssociatedDefault
      module procedure AssociatedOther
   end interface

   public :: allocate
   interface allocate
      module procedure AllocatePrivate
   end interface

   public :: nullify
   interface nullify
      module procedure Delete
   end interface

   public :: ftlSwap
   interface ftlSwap
       module procedure Swap
    end interface

contains



! ====== Implementation of ftlSharedPtr methods ==================================================================================


   ! Constructs a ftlSharedPtr object, depending on the signature used:
   !
   subroutine NewDefault(self)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      ! The object is empty (owns no pointer, use count of zero).

      call self%Delete()

   end subroutine
   !
   subroutine NewFromRawPtr(self, p)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      FTL_TEMPLATE_TYPE_WRAP, pointer               , intent(in)    :: p

      ! The object owns p, setting the use count to 1.

      call self%Delete()

      self%value => p
      allocate(self%refcount)
      self%refcount = 1

   end subroutine
   !
   subroutine NewFromOther(self, other)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(in)    :: other

      ! If other is not empty, the object shares ownership of other's assets and increases the use count.
      ! If other is empty, an empty object is constructed (as if default-constructed).

      call self%Delete()

      self%value => other%value
      self%refcount => other%refcount
      if (associated(self%refcount)) self%refcount = self%refcount + 1

   end subroutine



   ! Destroys the ftlSharedPtr object. But, before, it may produce the following side effects depending on the value
   ! of member refcount:
   !
   !  - If refcount is greater than 1 (i.e., the object is sharing ownership of its managed object with other ftlSharedPtr
   !    objects): The use count of the other objects with which it shares ownership is decreased by 1.
   !
   !  - If refcount is 1 (i.e., the object is the unique owner of the managed pointer): the object pointed by its owned
   !    pointer is deleted (if the ftlSharedPtr object was constructed with a specific deleter, this is called; Otherwise, the
   !    function uses operator delete).
   !
   !  - If refcount is zero (i.e., the object is empty), this destructor has no side effects.
   !
   subroutine Delete(self)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      if (.not. associated(self%refcount)) then
         return
      else if (self%refcount == 1) then
         ! TODO: call self%value destructor
         deallocate(self%value)
         deallocate(self%refcount)
      else if (self%refcount > 1) then
         self%refcount = self%refcount - 1
         nullify(self%value, self%refcount)
      endif

   end subroutine
   !
   subroutine Finalizer(self)
      type(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self
      call self%Delete()
   end subroutine



   ! Exchanges the contents of the shared_ptr object with those of x, transferring ownership of any managed object
   ! between them without destroying or altering the use count of either.
   !
   subroutine Swap(self, other)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self, other

      FTL_TEMPLATE_TYPE, pointer :: tmpValue
      integer          , pointer :: tmpRefcount

      tmpValue => self%value
      self%value => other%value
      other%value => tmpValue

      tmpRefcount => self%refcount
      self%refcount => other%refcount
      other%refcount => tmpRefcount

   end subroutine



   ! Returns the number of ftlSharedPtr objects that share ownership over the same pointer as this object (including it).
   !
   ! If this is an empty ftlSharedPtr, the function returns zero.
   !
   pure integer function UseCount(self)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: self

      if (associated(self%refcount)) then
         UseCount = self%refcount
      else
         UseCount = 0
      endif

   end function



   ! Returns whether the ftlSharedPtr object does not share ownership over its pointer with other ftlSharedPtr objects
   ! (i.e., it is unique).
   !
   ! Empty pointers are never unique (as they do not own any pointers).
   !
   ! Unique ftlSharedPtr objects are responsible to delete their managed object if they release this ownership (see the
   ! destructor).
   !
   ! This function returns the same as (useCount()==1).
   !
   pure logical function Unique(self)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: self

      Unique = (self%useCount() == 1)

   end function



   ! Define a function associated that works for ftlSharedPtrs like the Fortran intrinsic works for raw pointers
   ! pointers. This is instead of the operator== that is defined for std::shared_ptr in C++. We could do that in
   ! Fortran, but it would be a bit weird as normal Fortran raw pointer can not be compared with operator== ...
   !
   ! Unfortunately it's not possible to define associated between a ftlSmartPtr and normal pointers. People will have to
   ! use associated(smartPointer%value, rawPointer) for this.
   !
   pure logical function AssociatedDefault(self) result(assoc)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: self

      assoc = associated(self%value)

   end function
   !
   pure logical function AssociatedOther(sp1, sp2) result(assoc)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(in) :: sp1, sp2

      assoc = associated(sp1%value, sp2%value)

   end function


   ! Define an allocate subroutine that allows binding a new object to a ftlSharedPtr right away, so without first making
   ! a raw pointer and then calling the constructor.
   !
   subroutine AllocatePrivate(self)
      class(CAT(ftlSharedPtr,FTL_TEMPLATE_TYPE_NAME)), intent(inout) :: self

      if (associated(self%value)) then
         ! Just bail out. A normal Fortran pointer would allow this double allocation and would just leak the first
         ! allocation, but I don't see a good reason for replicating this behavior ...
         stop "double allocation error with ftlSharedPtr"
      else
         allocate(self%value)
         allocate(self%refcount)
         self%refcount = 1
      endif

   end subroutine


end module
#endif
