! Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and
! iteration in both directions.
!
! List containers are implemented as doubly-linked lists; Doubly linked lists can store each of the elements they contain
! in different and unrelated storage locations. The ordering is kept internally by the association to each element of a
! link to the element preceding it and a link to the element following it.
!
! They are very similar to forward_list: The main difference being that forward_list objects are single-linked lists, and
! thus they can only be iterated forwards, in exchange for being somewhat smaller and more efficient.
!
! Compared to other base standard sequence containers (array, vector and deque), lists perform generally better in
! Cinserting, extracting and moving elements in any position within the container for which an iterator has already been
! Cobtained, and therefore also in algorithms that make intensive use of these, like sorting algorithms.
!
! The main drawback of lists and forward_lists compared to these other sequence containers is that they lack direct access
! to the elements by their position; For example, to access the sixth element in a list, one has to iterate from a known
! position (like the beginning or the end) to that position, which takes linear time in the distance between these. They
! also consume some extra memory to keep the linking information associated to each element (which may be an important
! factor for large lists of small-sized elements).

#define STD_CONTAINER_PROVIDES_BIDIRECTIONAL_ITERATOR


module stdList/**/STD_TEMPLATE_TYPE_NAME/**/Module

#ifdef STD_TEMPLATE_TYPE_MODULE
   use STD_TEMPLATE_TYPE_MODULE
#endif

   implicit none
   private


! ====== Type of the stdList container itself ====================================================================================

   type :: ListNode
      class(ListNode), pointer :: prev => null()
      class(ListNode), pointer :: next => null()
   end type

   type, extends(ListNode) :: DataNode
      STD_TEMPLATE_TYPE :: data
   end type


   type, public :: stdList/**/STD_TEMPLATE_TYPE_NAME
      private

      integer                            :: psize = 0
      type(ListNode)                     :: sentinel
      STD_TEMPLATE_TYPE, pointer, public :: front => null()
      STD_TEMPLATE_TYPE, pointer, public :: back => null()

   contains
      private

      procedure         :: NewDefault
      procedure         :: NewCopyOther
      procedure         :: NewFill
      procedure         :: NewFromArray
      generic  , public :: New => NewDefault, NewCopyOther, NewFill, NewFromArray

      procedure, public :: Delete
      final             :: Finalizer

      procedure, public :: Begin
      procedure, public :: End

      procedure         :: SizeList
      generic  , public :: Size => SizeList

      procedure, public :: Empty

      procedure, public :: PushFront
      procedure, public :: PopFront
      procedure, public :: PushBack
      procedure, public :: PopBack

      procedure         :: FixValuePtrs

   end type

   public :: Size
   interface Size
      module procedure SizeList
   end interface


! ====== Type of an iterator over a stdList container ============================================================================

   type, public :: stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator
      private

      class(ListNode)                         , pointer         :: node => null()
      STD_TEMPLATE_TYPE                       , pointer, public :: value => null()

   contains
      private

      procedure         :: NewItDefault
      procedure         :: NewItCopyOther
      generic  , public :: New => NewItDefault, NewItCopyOther

      procedure, public :: Inc
      procedure, public :: Dec

   end type

   public :: operator(==)
   interface operator(==)
      module procedure EqualOther
   end interface

   public :: operator(/=)
   interface operator(/=)
      module procedure UnequalOther
   end interface


contains



! ====== Implementation of stdList methods =======================================================================================


   ! Constructs a list container object, initializing its contents depending on the constructor version used:
   !
   subroutine NewDefault(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(out), target :: self

      ! Constructs an empty list, with no elements.

      self%sentinel%next => self%sentinel
      self%sentinel%prev => self%sentinel

   end subroutine
   !
   subroutine NewCopyOther(self, other)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(in)  :: other

      type(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) :: it

      ! Constructs a list as a copy of another list.

      call self%New()

      it = other%Begin()
      do while (it /= other%End())
         call self%PushBack(it%value)
         call it%Inc()
      enddo

   end subroutine
   !
   subroutine NewFill(self, n, val)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(out)          :: self
      integer                                 , intent(in)           :: n
      STD_TEMPLATE_TYPE                       , intent(in), optional :: val

      ! Constructs a container with n elements. Each element is a copy of val (if present).

      integer :: i

      call self%New()

      do i = 1, n
         call self%PushBack(val)
      enddo

   end subroutine
   !
   subroutine NewFromArray(self, array)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(out) :: self
      STD_TEMPLATE_TYPE                       , intent(in)  :: array(:)

      ! Constructs a container with a copy of each of the elements in array, in the same order.

      integer :: i

      call self%New()

      do i = 1, size(array)
         call self%PushBack(array(i))
      enddo

   end subroutine



   subroutine Delete(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout), target :: self

      class(ListNode), pointer :: walker, deletor

      walker => self%sentinel%next
      do while (associated(walker) .and. .not.associated(walker,self%sentinel))
         deletor => walker
         walker => walker%next
         deallocate(deletor)
      enddo

      self%psize = 0
      nullify(self%sentinel%prev)
      nullify(self%sentinel%next)
      nullify(self%front)
      nullify(self%back)

   end subroutine

   subroutine Finalizer(self)
      type(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      call self%Delete()
   end subroutine



   ! =============> Iterators:

   ! Note: End method has to come first, otherwise this triggers https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60952


   ! Returns an iterator referring to the past-the-end element in the list container.
   !
   ! The past-the-end element is the theoretical element that would follow the last element in the list container. It does
   ! not point to any element, and thus shall not be dereferenced.
   !
   ! Because the ranges used by functions of the standard library do not include the element pointed by their closing
   ! iterator, this function is often used in combination with list%begin to specify a range including all the elements in
   ! the container.
   !
   ! If the container is empty, this function returns the same as list%begin.
   !
   type(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) function End(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(in), target :: self

      End%node => self%sentinel

   end function



   ! Returns an iterator pointing to the first element in the list container.
   !
   ! Notice that, unlike member list%front, which returns a reference to the first element, this function returns a bidirectional
   ! iterator pointing to it.
   !
   ! If the container is empty, the returned iterator value shall not be dereferenced.
   !
   type(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator) function Begin(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(in), target :: self

      Begin%node => self%sentinel%next
      select type (node => Begin%node)
      type is (DataNode)
         Begin%value => node%data
      end select

   end function



   ! =============> Capacity:



   ! Returns the number of elements in the list.
   !
   pure integer function SizeList(self) result(Size)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(in) :: self

      Size = self%psize

   end function


   ! Returns whether the list is empty (i.e. whether its size is 0).
   !
   ! This function does not modify the container in any way. To clear the content of a list, see stdList%clear.
   !
   pure logical function Empty(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(in) :: self

      Empty = (self%psize == 0)

   end function



   ! =============> Modifiers:


   ! TODO: remove all this code duplication ;-) ...


   ! Inserts a new element at the beginning of the list, right before its current first element. The content of val is copied
   ! (or moved) to the inserted element.
   !
   ! This effectively increases the container size by one.
   !
   subroutine PushFront(self, val)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout), target :: self
      STD_TEMPLATE_TYPE                       , intent(in)            :: val

      call InsertNodeAfter(self%sentinel%next%prev, val)
      self%psize = self%psize + 1
      call self%FixValuePtrs()

   end subroutine



   ! Removes the first element in the list container, effectively reducing its size by one.
   !
   ! This destroys the removed element.
   !
   STD_TEMPLATE_TYPE function PopFront(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout), target :: self

      class(ListNode), pointer :: oldfirst
      oldfirst => self%sentinel%next

      PopFront = self%front
      self%psize = self%psize - 1
      call UnlinkNode(oldfirst)
      deallocate(oldfirst)
      call self%FixValuePtrs()

   end function



   ! Adds a new element at the end of the list, after its current last element. The content of val is copied to
   ! the new element.
   !
   ! This effectively increases the container size by one.
   !
   subroutine PushBack(self, val)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self
      STD_TEMPLATE_TYPE                       , intent(in)    :: val

      call InsertNodeAfter(self%sentinel%prev, val)
      self%psize = self%psize + 1
      call self%FixValuePtrs()

   end subroutine



   ! Removes the last element in the list, effectively reducing the container size by one.
   !
   ! This destroys the removed element.
   !
   STD_TEMPLATE_TYPE function PopBack(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout), target :: self

      class(ListNode), pointer :: oldlast
      oldlast => self%sentinel%prev

      PopBack = self%back
      self%psize = self%psize - 1
      call UnlinkNode(oldlast)
      deallocate(oldlast)
      call self%FixValuePtrs()

   end function



   ! =============> Modifiers:



   subroutine InsertNodeAfter(afternode, val)
      class(ListNode), pointer, intent(inout) :: afternode
      STD_TEMPLATE_TYPE       , intent(in)    :: val

      class(ListNode), pointer :: oldnext, newnext

      oldnext => afternode%next
      allocate(DataNode::afternode%next)
      newnext => afternode%next
      newnext%prev => afternode
      newnext%next => oldnext
      oldnext%prev => newnext
      select type (newnext)
      type is (DataNode) ! always true
         newnext%data = val
      end select

   end subroutine



   subroutine UnlinkNode(node)
      class(ListNode), intent(inout) :: node

      node%next%prev => node%prev
      node%prev%next => node%next

   end subroutine



   subroutine FixValuePtrs(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME), intent(inout) :: self

      if (self%psize == 0) then
         nullify(self%front,self%back)
      else
         select type (first => self%sentinel%next)
         type is (DataNode)
            self%front => first%data
         end select
         select type (last => self%sentinel%prev)
         type is (DataNode)
            self%back => last%data
         end select
      endif

   end subroutine




! ====== Implementation of stdListIterator methods ===============================================================================



   subroutine NewItDefault(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(out) :: self

      ! Nothing to do here: intent(out) already resets everything

   end subroutine
   !
   subroutine NewItCopyOther(self, other)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(out) :: self
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in)  :: other

      self%node => other%node
      select type (node => self%node)
      type is (DataNode)
         self%value => node%data
      end select

   end subroutine



   ! =============> Arithmetic operations:



   subroutine Inc(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(inout) :: self

      self%node => self%node%next
      select type (node => self%node)
      type is (DataNode)
         self%value => node%data
      end select

   end subroutine
   !
   subroutine Dec(self)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(inout) :: self

      self%node => self%node%prev
      select type (node => self%node)
      type is (DataNode)
         self%value => node%data
      end select

   end subroutine



   ! =============> Logical operations:



   pure logical function EqualOther(self, other)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      EqualOther = associated(self%node,other%node)

   end function
   !
   pure logical function UnequalOther(self, other)
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: self
      class(stdList/**/STD_TEMPLATE_TYPE_NAME/**/Iterator), intent(in) :: other

      UnequalOther = .not.associated(self%node,other%node)

   end function


end module
